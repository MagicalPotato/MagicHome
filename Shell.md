* Shell指的是shell脚本编程. 大多linux默认执行shell脚本的Shell程序是bash  #!/bin/sh同样也可以改为 #!/bin/bash  其中#! 是一个约定的标记，
它告诉系统这个脚本需要什么解释器来执行，即使用哪一种 Shell程序。
* echo "xxxxx"  echo用于向窗口输出文本
* 执行脚本有两种方式,一种是让这个脚本文件具有可执行权限,另一种是把脚本文件当成解释器的参数.  第一种:首先cd到你的当前目录,给你当前目录下写的脚本添加可
执行权限 chmod +x ./test.sh ,当前目录是./ 如果不加./会默认去系统的path下找这个脚本,当然是找不到的. 权限加了之后就可以执行了 ./test.sh ,直接执行就是
在命令行输入脚本名称.  第二种: 直接把脚本当成参数传给解释器. /bin/sh test.sh
* Shell语言定义变量时,变量名前不加美元符号$,但是在php语言中需要. your_name="runoob.com" ,注意**shell中的变量和等号之间不能有空格**.可以在代码中使用命令语句for file in ``` `ls /etc` ```(注意这个不是单引号,是反引号,反引号中的内容是一个命令,比如你在反引号中写了data,那么输出的就是当前时间而不是data这个字符串) 或者for file in $(ls /etc) 该语句可以将/etc下目录的目录名称列出来
* 使用一个定义过的变量，只要在变量名前面加美元符号即可，如：your_name="qinjx" , echo $your_name 或者echo ${your_name}. 推荐在使用的时候给所有变量加上花括号，这是个好的编程习惯.
* readonly xxx 将xxx这个变量设置成只读变量  unset xxx 删除xxx变量,但不能删除只读变量,变量被删除后不能再次使用. 
* shell中的字符串可以使用单双引号,但稍有区别. 单引号中不能使用转义,哪怕使用了反斜杠也不行,也不会输出变量,反正就是啥都不能用,只会原样输出其中的内容.而双引号没有这个限制  string="abchhjkhjd",echo ${#string},加了#相当于是求字符串长度. echo ${string:1:4},从第二个字符开始截取四个字符
* Shell 中，用括号来表示数组，数组元素用"空格"符号分割开. array_name=(value0 value1 value2 value3).  也可以用下标来定义 array_name[0]=value0 .......array_name[n]=value0 可以不使用连续的下标，而且下标的范围没有限制.获取数组值的一般格式是使用下标 valuen=${array_name[下标]}, 使用 @ 符号可以获取数组中的所有元素 echo ${array_name[@]}, 取得数组元素的个数 length=${#array_name[@]}或者length=${#array_name[`*`]}
* shell中没有多行注释,只有单行注释 ,使用#号 . 
* echo "It is a test" > myfile 将结果输出到myfile文件  echo后加-e参数说明之后的东西将开始转义, \c的意思是不换行.  read -p "请输入一段文字:" -n 6 -t 5 -s password, echo -e "\npassword is $password" ,把这两条命令写入一个shell脚本中,然后执行该脚本,会输出如下东西: 请输入一段文字: 下一行:password is asdfgh .由此可以看出read的用法: -p参数是显示提示字符串, -n是限制输入文本的长度, -t是限制时间5分钟 ,-s是输入隐藏内容. 另外,read 命令一个一个词组地接收输入的参数，每个词组需要使用空格进行分隔；如果输入的词组个数大于需要的参数个数，则多出的词组将被作为整体为最后一个参数接收。
* printf 是echo的加强版,可移植性更好.但是printf打印出来之后不默认加换行,需要手动加.echo "ddd",那么ddd会默认在下一行显示,但是如果printf的话则是直接跟在后面,要换行的换需要手动添加换行的转义\n ,  printf "%-10s %-8s %-4.2f\n" 郭靖 男 66.1234 ,%s %c %d %f都是格式替代符%-10s 指一个宽度为10个字符（-表示左对齐，没有则表示右对齐），任何字符都会被显示在10个字符宽的字符内，如果不足则自动以空格填充，超过也会将内容全部显示出来。%-4.2f 指格式化为小数，其中.2指保留2位小数,注意4和.2是分开的,并不是4.2, 格式替代符%d %s %c %f详解:d: 对应位置参数必须是十进制整数，否则报错！,s: 对应位置参数必须是字符串或者字符型，否则报错！,c: Char--对应位置参数必须是字符串或者字符型，如果是个字符串会自动截取字符串的第一个字符当做输出值,否则报错！, f: Float 浮点 -- 对应位置参数必须是数字型，否则报错！
* 数值的比较用的是特殊的字符:-eq等于(可以用==),-ne不等于,-gt大于,-ge大于等于,-lt小于,-le小于等于,test用于测试条件是否成立,方框[]用于基本运算,不用[]表示是字符串,num1=100,num2=200, 那么比较两个值的方式是: test $[num1] -gt $[num2],这个例子中用了方框才表示num1和num2是数字,否则那么会把他们当成字符串来处理.result=$[5+9], 而字符串的比较用的是=好和!=号,num1="ru1noob",num2="xxx",test $num1=$num2,注意在shell中的所有地方等号左右两边都别加空格.和别的编程语言不一样,不一样,不一样!!!!  对文件的测试也是用特殊符号,if test -e ./bash,-e表示文件存在,-r文件存在且可读,-w,-x同理,-d存在且为目录,其他自查,另外，Shell还提供了与( -a )、或( -o )、非( ! )三个逻辑操作符用于将测试条件连接起来，其优先级为："!"最高，"-a"次之，"-o"最低。例如这个或的条件:if test -e ./notFile -o -e ./bash
* **无论是什么语言,最终都是对数据的处理,都离不开基本变量,条件,循环,判断,这些都是一门语言最基本的元素,而那些乱七八糟的方法或数据结构之类的,亦或者各种算法,最终都是为了数据服务._代码的本质就是完成数据的处理和传递_.所以,任何语言,无论语法如何变,其本质都不会改变**
* shell中的for,while,case:
```
for loop in 1 2 3 4 5
do
    echo "The value is: $loop"
done
--------------------------------
#!/bin/bash
int=1
while(( $int<=5 ))
do
    echo $int
    let "int++"      # Bash let 命令，它用于执行一个或多个表达式，变量计算中不需要加上 $ 来表示变量
done
--------------------------------
echo '输入 1 到 4 之间的数字:'
echo '你输入的数字为:'
read aNum
case $aNum in              # 取值后面必须为单词in，每一模式必须以右括号结束。
    1)  echo '你选择了 1'  # 取值可以为变量或常数。匹配发现取值符合某一模式后，其间所有命令开始执行直至 遇到两个分号;;
    ;;
    2)  echo '你选择了 2'  # 取值将检测匹配的每一个模式。一旦模式匹配，则执行完匹配模式相应命令后不再继续其他模式
    ;;
    3)  echo '你选择了 3'  # case的语法和C family语言差别很大，它需要一个esac（就是case反过来）作为结束标记，
    ;;
    4)  echo '你选择了 4'    #每个case分支用右圆括号，用两个分号表示break。
    ;;
    *)  echo '你没有输入 1 到 4 之间的数字'  # 如果无一匹配模式，使用星号 * 捕获该值，再执行后面的命令。 
    ;;
esac
----------------------------------
#!/bin/bash
while :
do
    echo -n "输入 1 到 5 之间的数字:"
    read aNum
    case $aNum in
        1|2|3|4|5) echo "你输入的数字为 $aNum!"
        ;;
        *) echo "你输入的数字不是 1 到 5 之间的! 游戏结束"
            break                       #    break用于跳出死循环!continue跳出当前循环!
        ;;
    esac
done
---------------------------------
#!/bin/bash
for((i=1;i<=5;i++));do                 # 通常情况下 shell 变量调用需要加 $,但是 for 的 (()) 中不需要
    echo "这是第 $i 次调用";
done;
```
* shell中的函数
```
funWithReturn(){        #所有函数在使用前必须定义。这意味着必须将函数放在脚本开始部分，直至shell解释器首次发现它时，才可以使用
    echo "这个函数会对输入的两个数字进行相加运算..."
    echo "输入第一个数字: "      #调用函数时可以向其传递参数。在函数体内部，通过 $n 的形式来获取参数的值，
    read aNum                    #例如，$1表示第一个参数，$2表示第二个参数...
    echo "输入第二个数字: "      #  $10 不能获取第十个参数，获取第十个参数需要${10}。当n>=10时，需要使用${n}来获取参数
    read anotherNum             # 所以为所有的参数加大括号是正规的编程
    echo "两个数字分别为 $aNum 和 $anotherNum !"
    return $(($aNum+$anotherNum))
}
funWithReturn
echo "输入的两个数字之和为 $? !"        #  函数返回值在调用该函数后通过 $? 来获得,调用函数仅使用其函数名即可。 
```
* 重定向
```
command > file 将输出重定向到 file。  # file内的已经存在的内容将被新内容替代。如果要将新内容添加在文件末尾，请使用>>操作符
command < file将输入重定向到 file。也就是从file中读入东西当做命令的参数.
command >> file将输出以追加的方式重定向到 file。
n > file将文件描述符为 n 的文件重定向到 file。      # 文件描述符 0 通常是标准输入（STDIN），1 是标准输出（STDOUT），2 是标准错误输出（STDERR）
n >> file将文件描述符为 n 的文件以追加的方式重定向到 file。
n >& m将输出文件 m 和 n 合并。
n <& m将输入文件 m 和 n 合并。
<< tag将开始标记 tag 和结束标记 tag 之间的内容作为输入。

$ who > users  # who 命令将完整的输出重定向在用户文件中users, 执行后，并没有在终端输出信息，因为输出已被从终端重定向到文件
$ cat users  #可以使用cat命令来查看文件中的内容
command1 < infile > outfile  # 同时替换输入和输出，执行command1，从文件infile读取内容，然后将输出写入到outfile中。

$ command > /dev/null  # 如果希望执行某个命令，但又不希望在屏幕上显示输出结果，那么可以将输出重定向到 /dev/null
/dev/null 是一个特殊的文件，写入到它的内容都会被丢弃；如果尝试从该文件读取内容，那么什么也读不到。但是 /dev/null 文件非常有用，
将命令的输出重定向到它，会起到"禁止输出"的效果。
如果希望屏蔽 stdout 和 stderr，可以这样写： $ command > /dev/null 2>&1
```

* 如果有两个脚本a.sh和b.sh,那么在b中引用a可以这样写, . ./a.sh , 注意第一个点表示引用文件,之后有个空格,然后./a.sh代表当前目录下你的a.sh文件,
还有另一种引用方式, source ./a.sh,注意source和目录文件之间也是有空格的.











