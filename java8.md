* hashmap底层初始化的时候会新建16个数组,然后每个数组有一个索引值.当一个新对象进来后,会根据hash方法来计算出一个索引值,但是无论怎么计算,你的这些索引值
肯定都是在那16个之中,所以说就会出现多个对象对应一个索引值的情况.这中情况就叫哈希碰撞.当发生哈希碰撞的时候,对象会被运到对应的数组里,然后和数组中的对象
进行比较,如果发现两个对象是相同的,那么就用新来的替换后来的.如果不一样,就会生成链表,把老的往后挪,新的加进来. 所以当重写了hashcode方法之后要重写equals
方法.但是无论你的hashcode方法和equals写的多么吊,哈希碰撞都是不可避免的.因此hashmap引入了一个加载因子,值是0.75,它的意思是当元素达到hashmap总容量的
75%的时候就进行扩容.当进行扩容的时候,原本在处于链表上的元素就会被重新hash,得到新的位置.这样碰撞的概率就会降低,那性能就会提高.碰撞多导致的问题就是
性能降低.因为假如你要判断某个元素和hashmap中的哪一个相同,经过hash计算得到了当前这个元素的hash索引,然后根据索引找到了了对应的数组链表,然后你开始和
链表上的元素进行一个个比较,如果元素很多且你找的那个恰好就是最后一个,那显而易见效率肯定低. 
* java8对hashmap的底层做了优化.当某个链上的元素大于8个,并且hashmap的总容量大于64的时候,链表会被直接转成红黑树.红黑树是个树节点,当一个元素过来,节点
上的元素会和当前元素的hashcode进行比较,如果当前的hashcode值大,则往向上的节点添加,小就往下添加,到达上一个或下一个节点还是一样的比较大小,大往上小往下,
这样的话除了添加元素慢一点,其他的效率都会有很大提升.在扩容的时候也不用在重新hash,而是直接加上扩大的容量.比如你当前这棵树是在16的位置,现在扩了10,那么
所有的树都整体往后移10个位置.新元素会放在前10个位置.同样的hashset也优化了,concurrentmap也是一样也进行了优化(以前的版本用的是锁分段机制,1.8用了CAS
算法).不过要注意一点,只有满足条件的时候链表才会转成红黑树,如果不满足条件,那就还是链表.所以1.8的hashmap底层是既有链表又有红黑树.
* 1.8对java的内存机制也进行了优化,以前有方法区(实际上就是堆的一部分,主要存类的信息,也会被回收,到是条件严格),现在堆的永久区和方法区都移除了,出现了一个
Metaspace(元空间).元空间直接用的是物理内存,你的物理内存有多大元空间就能利用多大.这样的话outofmemory异常出现的概率也就更低了(空间大了哪还能溢出).
同时与永久区相关的两个参数premgensize(初始永久)和maxpremgensize(最大永久)也就没了.取而代之就是metaspacesize和maxmetaspacesize.默认的是物理内存
多大元空间就能用多大,当然你可以自己配置.
* 多个相似的方法优化演变: 写多个方法每个不同的就一个地方>>策略模式,写一个接口,然后写多个实现类,实现类里实现不同的地方>>在方法里直接使用匿名内部类>>使
用lambda表达式>>使用Stream Api
* lambda表达式本质是对函数式(里面只有一个抽象方法)接口的扩展.所以使用lambda必须有函数式接口的支持,看如下例子:
```
public interface myInter
{
    public integer getValue(integer i);    //这个是函数式接口中的一个抽象方法 
}

在另一个类里有个方法要进行大小比较用到了这个接中的getValue抽象方法
public integer compare(integer i, myInter mi) 
{                           //实际上这就是策略模式中的那种方式.直接用一个类来实现接口的抽象方法,然后在使用
      return mi.getValue(i);  //的时候把已经实现的类对象传递进去,让实现类对象中的方法起作用.但是lambda的方式
} //实际上是将这个实现留空了,真正的实现在具体应用的时候再指定,而非像实现类中那样直接实现方法.避免了多个实现类.而且想实现成什么样就实现成什么样 

integer a = compare(100, (x) -> x*x)  //然后在使用的时候就可以直接使用lambda来对该方法进行实现
```
