* hashmap底层初始化的时候会新建16个数组,然后每个数组有一个索引值.当一个新对象进来后,会根据hash方法来计算出一个索引值,但是无论怎么计算,你的这些索引值
肯定都是在那16个之中,所以说就会出现多个对象对应一个索引值的情况.这中情况就叫哈希碰撞.当发生哈希碰撞的时候,对象会被运到对应的数组里,然后和数组中的对象
进行比较,如果发现两个对象是相同的,那么就用新来的替换后来的.如果不一样,就会生成链表,把老的往后挪,新的加进来. 所以当重写了hashcode方法之后要重写equals
方法.但是无论你的hashcode方法和equals写的多么吊,哈希碰撞都是不可避免的.因此hashmap引入了一个加载因子,值是0.75,它的意思是当元素达到hashmap总容量的
75%的时候就进行扩容.当进行扩容的时候,原本在处于链表上的元素就会被重新hash,得到新的位置.这样碰撞的概率就会降低,那性能就会提高.碰撞多导致的问题就是
性能降低.因为假如你要判断某个元素和hashmap中的哪一个相同,经过hash计算得到了当前这个元素的hash索引,然后根据索引找到了了对应的数组链表,然后你开始和
链表上的元素进行一个个比较,如果元素很多且你找的那个恰好就是最后一个,那显而易见效率肯定低. 
* java8对hashmap的底层做了优化.当某个链上的元素大于8个,并且hashmap的总容量大于64的时候,链表会被直接转成红黑树.红黑树是个树节点,当一个元素过来,节点
上的元素会和当前元素的hashcode进行比较,如果当前的hashcode值大,则往向上的节点添加,小就往下添加,到达上一个或下一个节点还是一样的比较大小,大往上小往下,
这样的话除了添加元素慢一点,其他的效率都会有很大提升.在扩容的时候也不用在重新hash,而是直接加上扩大的容量.比如你当前这棵树是在16的位置,现在扩了10,那么
所有的树都整体往后移10个位置.新元素会放在前10个位置.同样的hashset也优化了,concurrentmap也是一样也进行了优化(以前的版本用的是锁分段机制,1.8用了CAS
算法).不过要注意一点,只有满足条件的时候链表才会转成红黑树,如果不满足条件,那就还是链表.所以1.8的hashmap底层是既有链表又有红黑树.
