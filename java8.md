* hashmap底层初始化的时候会新建16个数组,然后每个数组有一个索引值.当一个新对象进来后,会根据hash方法来计算出一个索引值,但是无论怎么计算,你的这些索引值
肯定都是在那16个之中,所以说就会出现多个对象对应一个索引值的情况.这中情况就叫哈希碰撞.当发生哈希碰撞的时候,对象会被运到对应的数组里,然后和数组中的对象
进行比较,如果发现两个对象是相同的,那么就用新来的替换后来的.如果不一样,就会生成链表,把老的往后挪,新的加进来. 所以当重写了hashcode方法之后要重写equals
方法.但是无论你的hashcode方法和equals写的多么吊,哈希碰撞都是不可避免的.因此hashmap引入了一个加载因子,值是0.75,它的意思是当元素达到hashmap总容量的
75%的时候就进行扩容.当进行扩容的时候,原本在处于链表上的元素就会被重新hash,得到新的位置.这样碰撞的概率就会降低,那性能就会提高.碰撞多导致的问题就是
性能降低.因为假如你要判断某个元素和hashmap中的哪一个相同,经过hash计算得到了当前这个元素的hash索引,然后根据索引找到了了对应的数组链表,然后你开始和
链表上的元素进行一个个比较,如果元素很多且你找的那个恰好就是最后一个,那显而易见效率肯定低. 
