* 环境变量
装了软件之后一般要配置环境变量.以java为例会配置三个路径,一个ＪＡＶＡ＿ＨＯＭＥ，一个ｐａｔｈ，一个ｃｌａｓｓｐａｔｈ．
JAVA_HOME是你程序包存放的位置,path其实相当于是你这个软件能够执行的一些命令存放的路径,一般都是软件包中的bin目录.
而classepth是这个软件的一些你需要用的已经内置的文件所需要的路径,对于java来说就是一些已经编译好的.class文件所存放的地方.
当你要执行你这个程序的一些命令或者操作的时候,系统会优先去你配置的这些路径下面去寻找相关的命令或者操作,如果没配置,那就会去当前目录下去找,
如果当前目录下也没有,那系统就蒙逼了,就会报错.

* Spring中的IOC和aop:
  - 框架的主要作用基本上都是解耦合。就是降低代码耦合度
  - 控制反转(IOC)的基本概念是：不创建对象，但是描述创建它们的方式 ,是一种设计模式。就是对象的创建，依赖都由Spring及配置文件控制；
  - 一层含义是控制权的转移：由传统的在程序中控制依赖转移到由容器来控制；就是原本创建对象本来由代码控制变成由容器的配置文件来控制,
    在我需要对象的时候我就创建,不需要的时候我就不创建,而不是不管需不需要都在代码中创建一遍.第二层是依赖注入：将相互依赖的对象分离，
    在spring配置文件中描述他们的依赖关系。他们的依赖关系只在使用的时候才建立。
* 面向切面编程(也叫面向方面)(AOP)
   就是统一的给一些类似的方法加上同样的功能，比如日志，事务。主要的功能是：日志记录，性能统计，安全控制，事务处理，异常处理等等。
   主要的意图是：将日志记录，性能统计，安全控制，事务处理，异常处理等代码从业务逻辑代码中划分出来，通过对这些行为的分离，
   我们希望可以将它们独立到非指导业务逻辑的方法中，从而在改变这些行为的时候不影响业务逻辑的代码。

* 单例模式:
  有以下三个特点： 
  1 单例类只可有一个实例 
  2 单例类必须自己创建自己这惟一的实例 
  3 单例类必须给所有其他对象提供这一实例
    1 类的构造函数为private，即外部程序不能通过new关键字创建对象的实例
    2 类中提供一个private static的 类变量引用 ；
    3 单例类中提供静态方法 定义为 public static 的方法获取一个类的实例 ；
    4 静态方法返回 类的引用，即 第2点中的 私有 静态变量 。
      私有静态变量可以 定义的时候初始化 ，也可以 在第一次使用的时候，即调用AA.getInstanc()方法中判断 静态变量是否为空在初始化 。
       ``` java
       public class Singleton{    private static volatile Singleton instance=null;    private Singleton(){        //do something    } 
       public static  Singleton getInstance(){        if(instance==null){            synchronized(Singleton.class)
       {                if(instance==null){                    instance=new Singleton();
       //可以把线程这层判断去掉,同样可以使用.                 }            }        }        return instance;     }}
       ```
       //这个模式将同步内容下放到if内部，提高了执行的效率，不必每次获取对象时都进行同步，只有第一次才同步，创建了以后就没必要了。
       //这种模式中双重判断加同步的方式，因为如果单层if判断，在服务器允许的情况下，假设有一百个线程，耗费的时间为100*（同步判断时间+if判断时间），
       而如果双重if判断，100的线程可以同时if判断，理论消耗的时间只有一个if判断的时间。//所以如果面对高并发的情况，最好的选择就是双重判断加同步的方式。
       优点:省内存,效率高.  缺点:如果有个程序员不知道你这个类是单例模式,他就会用new的方式去创建对象,但是就会有问题,产生误解;
       一个类如果在不同的场景下用法不同就不适合.

* 微服务架构

  task不管分发任务,task创建主任务和分任务,并在rumprun中插入启动的sql,微服务会去定时扫描tumprun这个表,如果扫到有自己的任务该微服务就去运行这个任务.
当前这个微服务运行完成之后会根据squence表去查这个solution下一步是哪个微服务要运行,所以又会把tumprun中自己的这条任务删了并重新建一条下一个微服务的
任务,状态是3,下一个微服务如果领了任务之后就会把状态改成2继续运行...........直到最后一个微服务运行完成之后就会把tumprun表的sql删了,并把主任务的状态
设成100就算这个过程结束了.最后一个微服务一般都会把任务结果再处理出来展示给页面.

* 杂谈

  能在缺乏条件的情况下把事情做好，才叫真牛逼同样是上司布置任务一个人就马上回到位置上开始筹备，抓紧每分每秒。另一个人就开始啰里吧嗦，讲条件，
说什么——时间太紧迫，不能多给两天吗？人手也不够啊，能让小张也来帮忙吗？非要三个方案啊，两个行不行？这种话是不是很熟悉？听了这种话，你是不是很想揍他？
其实通常情况下，你的上司安排的任务，都是会考虑实际情况的，除非他有病。如果他真的有病，你可以辞职啊。乔布斯说过，优秀的员工只要告诉他要做什么事要什么
效果，他就会想办法搞定。越是出色的人越善于在缺乏条件的状态下把事情做到最好，越是平庸的人越是对做事的条件挑三拣四。千万别以为你讲了条件，你就省力了，
你就方便了，你只会给上司“你丫无能”的印象。一位不愿透露姓名的爸爸，马云说过，公司请你来是解决问题的，不是制造问题。你能解决多大的问题，你就坐多高的位子
  你能解决多少问题，你就能拿多少薪水。如果你不能发现问题或解决不了问题，你本人就是一个问题。让解决问题的人高升，让制造问题的人让位，让抱怨问题的人下课。爸爸说得真棒。

* arraylist和linkedList

  arrayList 底层是数组, 新加对象的时候先会判断原始数组够不够,够的话直接加,不够的话先新建一个大数组,然后再把老数组的对象全都拷贝过去,然后再把新对象加
进去,最后把新数组的地址交给老数组的引用.  由于是数组,所以往中间插入和删除会移动数据,如果有频繁的往中间(只是往中间,如果都是在末尾,实际上arrayList还是
很高效,毕竟链表还要单独去维护地址)删除插入操作不建议使用,耗内存多.  实际使用中百万级以上的数据才会考虑选哪个,小数据的话其实还是arrayList效率高
linkdList 底层是链表 ,一开始分配的内存都是固定的,频繁的删除和插入并不会移动数据,所以当需要频繁删除或插入特别大量数据的时候比arrayList效率要高.
但如果只是小数据或者大数据只是单纯的查询话,arrayList还是更好.

* 拷贝

  浅拷贝只是把对象地址交给引用, 而深拷贝则是原来的东西全都复制到一个新的地址中去放一份然后再把指针指向新地址.  如果用的是浅拷贝,有可能会出现这个问题:
如果引用a已经手动释放了对象的内存,那么同样的引用B再次释放同一块内存的时候就会报释放同一内存的错误.
ArrayList  a = oldArrayList.clone()浅 
ArrayList  a = new ArrayList(oldList)  浅
Collection.copy()  深

* 内存

  
  连接内存和寄存器的是地址总线，地址总线的宽度影响了物理地址的索引范围，因为总线宽度决定了处理器一次可以从寄存器或内存中获取多少个Bit，同时也决定了处理器最大可以寻址的地址空间。比如32位CPU的系统，可寻址范围为0x00000000~0xFFFFFFFF，即232=4294967296个内存位置，每个内存位置1个字节，即32位CPU系统可以有4GB的内存空间。不过应用程序是不可以完全使用这些地址空间的，因为这些地址空间被划分为了内核空间和用户空间，程序只能使用用户空间的内存。内核空间主要是指操作系统运行时所使用的用于程序调度、虚拟内存的使用或者链接硬件资源的程序逻辑。
  
  说到Java内存区域，可能很多人第一反应是“堆栈”。首先堆栈不是一个概念，而是两个概念，堆和栈是两块不同的内存区域，简单理解的话，堆是用来存放对象而栈是用来执行程序的。其次，堆内存和栈内存的这种划分方式比较粗糙，这种划分方式只能说明大多数程序员最关注的、与对象内存分配关系最密切的内存区域是这两块，Java内存区域的划分实际上远比这复杂。对于Java程序员来说，在虚拟机自动内存管理机制的帮助下，不再需要为每一个new操作去配对delete/free代码，不容易出现内存泄露和内存溢出问题。但是，也正是因为Java把内存控制权交给了虚拟机，一旦出现内存泄露和内存溢出的问题，就难以排查，因此一个好的Java程序员应该去了解虚拟机的内存区域以及会引起内存泄露和内存溢出的场景。
  
.class文件的第5~第8个字节表示的是该.class文件的主次版本号，验证的时候会对这4个字节做一个验证，高版本的JDK能向下兼容以前版本的.class文件，但不能运行以后的class文件，即使文件格式未发生任何变化，虚拟机也必须拒绝执行超过其版本号的.class文件。举个具体的例子，如果一段.java代码是在JDK1.6下编译的，那么JDK1.6、JDK1.7的环境能运行这个.java代码生成的.class文件，但是JDK1.5、JDK1.4乃更低的JDK版本是无法运行这个.java代码生成的.class文件的。如果运行，会抛出java.lang.UnsupportedClassVersionError，这个小细节，务必注意。
