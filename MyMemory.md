* 环境变量
装了软件之后一般要配置环境变量.以java为例会配置三个路径,一个ＪＡＶＡ＿ＨＯＭＥ，一个ｐａｔｈ，一个ｃｌａｓｓｐａｔｈ．
JAVA_HOME是你程序包存放的位置,path其实相当于是你这个软件能够执行的一些命令存放的路径,一般都是软件包中的bin目录.
而classepth是这个软件的一些你需要用的已经内置的文件所需要的路径,对于java来说就是一些已经编译好的.class文件所存放的地方.
当你要执行你这个程序的一些命令或者操作的时候,系统会优先去你配置的这些路径下面去寻找相关的命令或者操作,如果没配置,那就会去当前目录下去找,
如果当前目录下也没有,那系统就蒙逼了,就会报错.

* Spring中的IOC和aop:
  - 框架的主要作用基本上都是解耦合。就是降低代码耦合度
  - 控制反转(IOC)的基本概念是：不创建对象，但是描述创建它们的方式 ,是一种设计模式。就是对象的创建，依赖都由Spring及配置文件控制；
  - 一层含义是控制权的转移：由传统的在程序中控制依赖转移到由容器来控制；就是原本创建对象本来由代码控制变成由容器的配置文件来控制,
    在我需要对象的时候我就创建,不需要的时候我就不创建,而不是不管需不需要都在代码中创建一遍.第二层是依赖注入：将相互依赖的对象分离，
    在spring配置文件中描述他们的依赖关系。他们的依赖关系只在使用的时候才建立。
* 面向切面编程(也叫面向方面)(AOP)
   就是统一的给一些类似的方法加上同样的功能，比如日志，事务。主要的功能是：日志记录，性能统计，安全控制，事务处理，异常处理等等。
   主要的意图是：将日志记录，性能统计，安全控制，事务处理，异常处理等代码从业务逻辑代码中划分出来，通过对这些行为的分离，
   我们希望可以将它们独立到非指导业务逻辑的方法中，从而在改变这些行为的时候不影响业务逻辑的代码。

* 单例模式:
  有以下三个特点： 
  1 单例类只可有一个实例 
  2 单例类必须自己创建自己这惟一的实例 
  3 单例类必须给所有其他对象提供这一实例
    1 类的构造函数为private，即外部程序不能通过new关键字创建对象的实例
    2 类中提供一个private static的 类变量引用 ；
    3 单例类中提供静态方法 定义为 public static 的方法获取一个类的实例 ；
    4 静态方法返回 类的引用，即 第2点中的 私有 静态变量 。
      私有静态变量可以 定义的时候初始化 ，也可以 在第一次使用的时候，即调用AA.getInstanc()方法中判断 静态变量是否为空在初始化 。
       ``` java
       public class Singleton{    private static volatile Singleton instance=null;    private Singleton(){        //do something    } 
       public static  Singleton getInstance(){        if(instance==null){            synchronized(Singleton.class)
       {                if(instance==null){                    instance=new Singleton();
       //可以把线程这层判断去掉,同样可以使用.                 }            }        }        return instance;     }}
       ```
       //这个模式将同步内容下放到if内部，提高了执行的效率，不必每次获取对象时都进行同步，只有第一次才同步，创建了以后就没必要了。
       //这种模式中双重判断加同步的方式，因为如果单层if判断，在服务器允许的情况下，假设有一百个线程，耗费的时间为100*（同步判断时间+if判断时间），
       而如果双重if判断，100的线程可以同时if判断，理论消耗的时间只有一个if判断的时间。//所以如果面对高并发的情况，最好的选择就是双重判断加同步的方式。
       优点:省内存,效率高.  缺点:如果有个程序员不知道你这个类是单例模式,他就会用new的方式去创建对象,但是就会有问题,产生误解;
       一个类如果在不同的场景下用法不同就不适合.

* 微服务架构

  task不管分发任务,task创建主任务和分任务,并在rumprun中插入启动的sql,微服务会去定时扫描tumprun这个表,如果扫到有自己的任务该微服务就去运行这个任务.
当前这个微服务运行完成之后会根据squence表去查这个solution下一步是哪个微服务要运行,所以又会把tumprun中自己的这条任务删了并重新建一条下一个微服务的
任务,状态是3,下一个微服务如果领了任务之后就会把状态改成2继续运行...........直到最后一个微服务运行完成之后就会把tumprun表的sql删了,并把主任务的状态
设成100就算这个过程结束了.最后一个微服务一般都会把任务结果再处理出来展示给页面.

* 杂谈

  能在缺乏条件的情况下把事情做好，才叫真牛逼同样是上司布置任务一个人就马上回到位置上开始筹备，抓紧每分每秒。另一个人就开始啰里吧嗦，讲条件，
说什么——时间太紧迫，不能多给两天吗？人手也不够啊，能让小张也来帮忙吗？非要三个方案啊，两个行不行？这种话是不是很熟悉？听了这种话，你是不是很想揍他？
其实通常情况下，你的上司安排的任务，都是会考虑实际情况的，除非他有病。如果他真的有病，你可以辞职啊。乔布斯说过，优秀的员工只要告诉他要做什么事要什么
效果，他就会想办法搞定。越是出色的人越善于在缺乏条件的状态下把事情做到最好，越是平庸的人越是对做事的条件挑三拣四。千万别以为你讲了条件，你就省力了，
你就方便了，你只会给上司“你丫无能”的印象。一位不愿透露姓名的爸爸，马云说过，公司请你来是解决问题的，不是制造问题。你能解决多大的问题，你就坐多高的位子
  你能解决多少问题，你就能拿多少薪水。如果你不能发现问题或解决不了问题，你本人就是一个问题。让解决问题的人高升，让制造问题的人让位，让抱怨问题的人下课。爸爸说得真棒。

* arraylist和linkedList

  arrayList 底层是数组, 新加对象的时候先会判断原始数组够不够,够的话直接加,不够的话先新建一个大数组,然后再把老数组的对象全都拷贝过去,然后再把新对象加
进去,最后把新数组的地址交给老数组的引用.  由于是数组,所以往中间插入和删除会移动数据,如果有频繁的往中间(只是往中间,如果都是在末尾,实际上arrayList还是
很高效,毕竟链表还要单独去维护地址)删除插入操作不建议使用,耗内存多.  实际使用中百万级以上的数据才会考虑选哪个,小数据的话其实还是arrayList效率高
linkdList 底层是链表 ,一开始分配的内存都是固定的,频繁的删除和插入并不会移动数据,所以当需要频繁删除或插入特别大量数据的时候比arrayList效率要高.
但如果只是小数据或者大数据只是单纯的查询话,arrayList还是更好.

* 拷贝

  浅拷贝只是把对象地址交给引用, 而深拷贝则是原来的东西全都复制到一个新的地址中去放一份然后再把指针指向新地址.  如果用的是浅拷贝,有可能会出现这个问题:
如果引用a已经手动释放了对象的内存,那么同样的引用B再次释放同一块内存的时候就会报释放同一内存的错误.
ArrayList  a = oldArrayList.clone()浅 
ArrayList  a = new ArrayList(oldList)  浅
Collection.copy()  深

* 内存

  
  连接内存和寄存器的是地址总线，地址总线的宽度影响了物理地址的索引范围，因为总线宽度决定了处理器一次可以从寄存器或内存中获取多少个Bit，同时也决定了处理器最大可以寻址的地址空间。比如32位CPU的系统，可寻址范围为0x00000000~0xFFFFFFFF，即232=4294967296个内存位置，每个内存位置1个字节，即32位CPU系统可以有4GB的内存空间。不过应用程序是不可以完全使用这些地址空间的，因为这些地址空间被划分为了内核空间和用户空间，程序只能使用用户空间的内存。内核空间主要是指操作系统运行时所使用的用于程序调度、虚拟内存的使用或者链接硬件资源的程序逻辑。
  
  说到Java内存区域，可能很多人第一反应是“堆栈”。首先堆栈不是一个概念，而是两个概念，堆和栈是两块不同的内存区域，简单理解的话，堆是用来存放对象而栈是用来执行程序的。其次，堆内存和栈内存的这种划分方式比较粗糙，这种划分方式只能说明大多数程序员最关注的、与对象内存分配关系最密切的内存区域是这两块，Java内存区域的划分实际上远比这复杂。对于Java程序员来说，在虚拟机自动内存管理机制的帮助下，不再需要为每一个new操作去配对delete/free代码，不容易出现内存泄露和内存溢出问题。但是，也正是因为Java把内存控制权交给了虚拟机，一旦出现内存泄露和内存溢出的问题，就难以排查，因此一个好的Java程序员应该去了解虚拟机的内存区域以及会引起内存泄露和内存溢出的场景。
  
  .class文件的第5~第8个字节表示的是该.class文件的主次版本号，验证的时候会对这4个字节做一个验证，高版本的JDK能向下兼容以前版本的.class文件，但不能运行以后的class文件，即使文件格式未发生任何变化，虚拟机也必须拒绝执行超过其版本号的.class文件。举个具体的例子，如果一段.java代码是在JDK1.6下编译的，那么JDK1.6、JDK1.7的环境能运行这个.java代码生成的.class文件，但是JDK1.5、JDK1.4乃更低的JDK版本是无法运行这个.java代码生成的.class文件的。如果运行，会抛出java.lang.UnsupportedClassVersionError，这个小细节，务必注意。
  
***
## 类加载机制

对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。这句话表达地再简单一点就是：比较两个类是否"相等"，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则即使这两个类来源于同一个.class文件，被同一个虚拟机加载，只要加载它们的类加载器不同，这两个类必定不相等。
  
  
* java的三个类加载器:
  1 启动类加载器Bootstrap ClassLoader :一个嵌在JVM内核中的加载器。它负责加载的是JAVA_HOME/lib下的类库，属于系统级加载器,无法被Java程序直接应用
  2 扩展类加载器Extension ClassLoader:由 sun.misc.Launcher$ExtClassLoader 实现，它负责用于加载JAVA_HOME/lib/ext目录中的，或者被java.ext.dirs系统变量指定所指定的路径中所有类库，者可以直接使用扩展类加载器。
  3 应用程序类加载器Application ClassLoader :这个类加载器由 sun.misc.Launcher$AppClassLoader 实现。这个类也一般被称为 系统的 类加载器.      Application ClassLoader只能加载项目bin目录下的.class文件。
  
  
- System.out.println(System.getProperty("java.ext.dirs"));   sun.misc.Launcher$AppClassLoader@546b97fd
- System.out.printlngetSystemClassLoader().getParent());   sun.misc.Launcher$ExtClassLoader@535ff48b
- System.out.println(ClassLoader.getSystemClassLoader().getParent().getParent());  null    
```
Bootstrap ClassLoader以外的ClassLoader都是Java实现的，因此这些ClassLoader势必在Java堆中有一份实例在，所以Extension ClassLoader和Application ClassLoader都能打印出内容来。但是Bootstrap ClassLoader是JVM的一部分，是用C/C++写的，不属于Java，自然在Java堆中也没有自己的空间，所以就返回null了。所以，如果ClassLoader得到的是null，那么表示的ClassLoader就是Bootstrap ClassLoader。
```
  
  - 双亲委派模型是在JDK1.2期间被引入的，其工作过程可以分为两步：  
===
  * 如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此。
  * 只有当父加载器反馈自己无法完成这这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载所以，其实所有的加载请求最终都应该传送到顶层的启动类加载器中。双亲委派模型对于Java程序的稳定运作很重要，因为Java类随着它的加载器一起具备了一种带有优先级的层次关系。例如java.lang.Object，存放于rt.jar中，无论哪一个类加载器要去加载这个类，最终都是由Bootstrap ClassLoader去加载,因此Object类在程序的各种类加载器环境中都是一个类。相反，如果没有双亲委派模型，由各个类自己去加载的话，如果用户自己编写了一个java.lang.Object，并放在CLASSPATH下，那系统中将会出现多个不同的Object类，Java体系中最基础的行为也将无法保证，应用程序也将会变得一片混乱。
===
