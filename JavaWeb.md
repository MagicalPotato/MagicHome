### JavaI/O
1. java中的I/O操作大体上可以被分成四组:
   - 基于字节操作的接口: InputStream 和 OutStream
   - 基于字符操作的接口: Writer 和 Reader
   - 基于硬盘操作的接口: File
   - 基于网络操作的接口: Socket 
2. 同步I/O指的是直接从硬盘去读取数据,这样省去了异步的一次数据复制(异步是先复制到缓存再复制给程序)但是这样通常会增加开销,而且很慢.异步I/O是程序在读写的时候先去读写操作系统提供的数据缓存,有的话直接拿来用,没有的话再去硬盘取.也就是异步会维持一个缓存区.程序每取一次新数据,都会在缓存区放一份以便于下次再取.将同步和异步结合起来使用能提高效率.比如像一些热点数据我可以用缓存,但是一些不常用的数据就没必要用缓存(因为缓存也耗资源啊,如果这个不常用的数据很大,先复制到缓存,再复制给程序,就浪费了很多资源).

### Java虚拟机
1. javac是Java的编译器,能将Java语言规范转换成Java虚拟机语言规范(也就是将Java源码编译成Java字节码,字节码就是jvm能够识别的二进制码).大多语言都是将源码直接编译成机器语言,而Java是先将源码编译成Java虚拟机理解的语言,然后虚拟机再讲编译后的语言编译成机器语言.这是Java能够跨平台的根本原因.并不是只有Java才用Java虚拟机,很多其他的语言也会用Java虚拟机.

### http中的cookie和session
1. 别听网上那些傻逼乱七八槽的比比,实际上cookie就相当于一张身份证,一张服务器给浏览器办的身份识别卡.当浏览器第一次访问服务器时,服务器会将一些信息用key-value的形式传给浏览器,这些信息就相当于一张身份识别卡,当浏览器下次再来访问的时候,你需要把浏览器之前给你的键值对再带着给服务器看,通过确认之后服务器就知道你是人家会员,这样你就可以免去一些繁琐的检查直接开始使用服务器了(服务器也会根据session来做出合理的规划,因为很多网站的服务器都会有很多,将某一些浏览器的session都分配给指定的服务器来处理,那么可以很好的实现分布式和负载均衡,而且会省去很多重复的认证过程.而且由于cookie是存在浏览器,每次访问都要带着这个cookie,也避免了同一个用户的请求可能不是同一台服务器处理而导致的cookie不一致的问题.).要注意这里的身份证和我们理解身份证不太一样,这里是一堆身份证.浏览器每向服务器请求一个资源,服务器就会给浏览器这样一个证,这个证仅用于认证浏览器当前访问的这个资源.服务器会根据浏览器的访问量来对cookie做出划分,可以热点数据进行缓存,并将热点数据的cookie放到一起这样就可以提升效率.  但是浏览器对cookie的缓存是有限制的,而且每次和服务器传送数据的时候外带cookie,如果访问量多的话那对宽带也是一种很不小的消耗.在这个背景下,session就出现了. session相当于是给每个浏览器唯一的一个id,如果一个浏览器第一次访问服务器,那么服务器就为这个浏览器制作一个唯一的sessionid并通过servlet的unlodde方法将session持久化到文件中,并在第一次相应的时候传给浏览器,下次浏览器来只要带着这个sessionid,然后servlet再从文件中解析出sessionid如果匹配那么就可以进行数据交互了.

### Spring
1. Spring的核心组件有三个:Core,Context,Bean.而Bean是核心中的核心.Bean之于Spring就如Object之于OOP.Spring为何如此流行,是因为它解决了一个非常关键的问题,它可以让你把对象之间的依赖关系转而用配置文件来管理,这就是依赖注入机制,而这个注入关系在一个叫IOC的容器中管理.IOC容器是被Bean包裹的对象.Spring通过把对象包裹在Bean中从而达到管理对象以及做一系列额外操作的目的.
2. bean包装对象,而context发现并且维护很多bean之间的关系,相当于是给Spring提供了一个运行环境,用以保存各个对象bean的状态,而core是context用来发现和维护bean之间关系的工具,相当的util. context又可以称之为bean关系的集合,这个集合里bean是对象,core充当工具,整个这个集合又叫ioc容器.这个容器可以根据你的需要来为你创造一些你想要的特性,而aop就是通过这个可以自己造特性的功能实现的一种特性. 
3. AOP是基于JDK的动态代理实现的.动态代理就是当你调用一个类A的A方法时,会让你去执行类B的A方法(给某个对象创建一个代理对象,由这个代理对象控制对原对象的引用,而创建这个代理对象后可以在调用原对象时增加一些额外的操纵,例如打日志),类似于是行为转嫁,我要干的事情让别人去干.这也是大家都说面向切面的原因.因为面向切面其实就是行为转嫁,它分离了业务逻辑和系统级的服务,代码里我安心写逻辑,而一些服务性的东西可以代理让别的类去做,例如审计,事务,日志等.
4. **Spring和SpringMVC并不是一回事**:Spring严格上来说，并不是一种框架。它相当于一个粘合剂，黏合了别的框架或者组件。所以，spring的本质是一个容器.而SpringMVC是spring扩展出的一个应用于web端的框架. 我们在应用spring的时候,可以使用注入。这个时候，如果我们的web端是用的SpringMVC，controller理论上是通过SpringMVC去注入，但是，使用spring注入，同样是可行的。同理，service等层，使用SpringMVC配置的统一扫描装配也是可以的。所以，如果说只是为了使用spring的依赖注入，是大可不必将springMVC和spring同时使用的。他们完全可以分开!   
5. Struts也是对于MVC的一种非常完美的实现，从根本上来说，它其实和SpringMVC一样，都是基于MVC思想的扩展实现。但是，在实践中Spring渐渐超越了Struts.如果说项目中使用了spring，那么还是使用SpringMVC吧，因为相对于融合Struts来说，spring和SpringMVC是非常完美的无缝链接。其次，SpringMVC的拦截粒度是方法，而Struts的粒度是类;然后，入口不同，SpringMVC的入口是servlet，而Struts是filter;最后，如果使用注解的话，SpringMVC基本上是零配置，而Struts需要配置很多。
6. 架构>框架>设计模式。软件通过架构，可以设计出很多不同的框架。在一个框架中，也可以使用很多的设计模式。设计模式不是哪儿哪儿都可以用的，只有当出现了某一特定的问题时，才利用设计模式去解决。设计模式不是用的越多越好，在维护的时候，过多的设计模式会极大的增添维护成本。架构的抽象层级比之框架更高。框架更加倾向于技术，架构更倾向于设计，架构可以通过不同的框架来实现。
