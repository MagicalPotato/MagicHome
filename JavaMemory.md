* 环境变量
装了软件之后一般要配置环境变量.以java为例会配置三个路径,一个ＪＡＶＡ＿ＨＯＭＥ，一个ｐａｔｈ，一个ｃｌａｓｓｐａｔｈ．
JAVA_HOME是你程序包存放的位置,path其实相当于是你这个软件能够执行的一些命令存放的路径,一般都是软件包中的bin目录.
而classepth是这个软件的一些你需要用的已经内置的文件所需要的路径,对于java来说就是一些已经编译好的.class文件所存放的地方.
当你要执行你这个程序的一些命令或者操作的时候,系统会优先去你配置的这些路径下面去寻找相关的命令或者操作,如果没配置,那就会去当前目录下去找,
如果当前目录下也没有,那系统就蒙逼了,就会报错.

* Spring中的IOC和aop:
  - 框架的主要作用基本上都是解耦合。就是降低代码耦合度
  - 控制反转(IOC)的基本概念是：不创建对象，但是描述创建它们的方式 ,是一种设计模式。就是对象的创建，依赖都由Spring及配置文件控制；
  - 一层含义是控制权的转移：由传统的在程序中控制依赖转移到由容器来控制；就是原本创建对象本来由代码控制变成由容器的配置文件来控制,
    在我需要对象的时候我就创建,不需要的时候我就不创建,而不是不管需不需要都在代码中创建一遍.第二层是依赖注入：将相互依赖的对象分离，
    在spring配置文件中描述他们的依赖关系。他们的依赖关系只在使用的时候才建立。
* 面向切面编程(也叫面向方面)(AOP)
   就是统一的给一些类似的方法加上同样的功能，比如日志，事务。主要的功能是：日志记录，性能统计，安全控制，事务处理，异常处理等等。
   主要的意图是：将日志记录，性能统计，安全控制，事务处理，异常处理等代码从业务逻辑代码中划分出来，通过对这些行为的分离，
   我们希望可以将它们独立到非指导业务逻辑的方法中，从而在改变这些行为的时候不影响业务逻辑的代码。

* 单例模式:
  有以下三个特点： 
  1 单例类只可有一个实例 
  2 单例类必须自己创建自己这惟一的实例 
  3 单例类必须给所有其他对象提供这一实例
    1 类的构造函数为private，即外部程序不能通过new关键字创建对象的实例
    2 类中提供一个private static的 类变量引用 ；
    3 单例类中提供静态方法 定义为 public static 的方法获取一个类的实例 ；
    4 静态方法返回 类的引用，即 第2点中的 私有 静态变量 。
      私有静态变量可以 定义的时候初始化 ，也可以 在第一次使用的时候，即调用AA.getInstanc()方法中判断 静态变量是否为空在初始化 。
       ``` java
       public class Singleton{    private static volatile Singleton instance=null;    private Singleton(){        //do something    } 
       public static  Singleton getInstance(){        if(instance==null){            synchronized(Singleton.class)
       {                if(instance==null){                    instance=new Singleton();
       //可以把线程这层判断去掉,同样可以使用.                 }            }        }        return instance;     }}
       ```
       //这个模式将同步内容下放到if内部，提高了执行的效率，不必每次获取对象时都进行同步，只有第一次才同步，创建了以后就没必要了。
       //这种模式中双重判断加同步的方式，因为如果单层if判断，在服务器允许的情况下，假设有一百个线程，耗费的时间为100*（同步判断时间+if判断时间），
       而如果双重if判断，100的线程可以同时if判断，理论消耗的时间只有一个if判断的时间。//所以如果面对高并发的情况，最好的选择就是双重判断加同步的方式。
       优点:省内存,效率高.  缺点:如果有个程序员不知道你这个类是单例模式,他就会用new的方式去创建对象,但是就会有问题,产生误解;
       一个类如果在不同的场景下用法不同就不适合.

* 微服务架构

  task不管分发任务,task创建主任务和分任务,并在rumprun中插入启动的sql,微服务会去定时扫描tumprun这个表,如果扫到有自己的任务该微服务就去运行这个任务.
当前这个微服务运行完成之后会根据squence表去查这个solution下一步是哪个微服务要运行,所以又会把tumprun中自己的这条任务删了并重新建一条下一个微服务的
任务,状态是3,下一个微服务如果领了任务之后就会把状态改成2继续运行...........直到最后一个微服务运行完成之后就会把tumprun表的sql删了,并把主任务的状态
设成100就算这个过程结束了.最后一个微服务一般都会把任务结果再处理出来展示给页面.

* 杂谈

  能在缺乏条件的情况下把事情做好，才叫真牛逼同样是上司布置任务一个人就马上回到位置上开始筹备，抓紧每分每秒。另一个人就开始啰里吧嗦，讲条件，
说什么——时间太紧迫，不能多给两天吗？人手也不够啊，能让小张也来帮忙吗？非要三个方案啊，两个行不行？这种话是不是很熟悉？听了这种话，你是不是很想揍他？
其实通常情况下，你的上司安排的任务，都是会考虑实际情况的，除非他有病。如果他真的有病，你可以辞职啊。乔布斯说过，优秀的员工只要告诉他要做什么事要什么
效果，他就会想办法搞定。越是出色的人越善于在缺乏条件的状态下把事情做到最好，越是平庸的人越是对做事的条件挑三拣四。千万别以为你讲了条件，你就省力了，
你就方便了，你只会给上司“你丫无能”的印象。一位不愿透露姓名的爸爸，马云说过，公司请你来是解决问题的，不是制造问题。你能解决多大的问题，你就坐多高的位子
  你能解决多少问题，你就能拿多少薪水。如果你不能发现问题或解决不了问题，你本人就是一个问题。让解决问题的人高升，让制造问题的人让位，让抱怨问题的人下课。爸爸说得真棒。

* arraylist和linkedList

  arrayList 底层是数组, 新加对象的时候先会判断原始数组够不够,够的话直接加,不够的话先新建一个大数组,然后再把老数组的对象全都拷贝过去,然后再把新对象加
进去,最后把新数组的地址交给老数组的引用.  由于是数组,所以往中间插入和删除会移动数据,如果有频繁的往中间(只是往中间,如果都是在末尾,实际上arrayList还是
很高效,毕竟链表还要单独去维护地址)删除插入操作不建议使用,耗内存多.  实际使用中百万级以上的数据才会考虑选哪个,小数据的话其实还是arrayList效率高
linkdList 底层是链表 ,一开始分配的内存都是固定的,频繁的删除和插入并不会移动数据,所以当需要频繁删除或插入特别大量数据的时候比arrayList效率要高.
但如果只是小数据或者大数据只是单纯的查询话,arrayList还是更好.

* 拷贝

  浅拷贝只是把对象地址交给引用, 而深拷贝则是原来的东西全都复制到一个新的地址中去放一份然后再把指针指向新地址.  如果用的是浅拷贝,有可能会出现这个问题:
如果引用a已经手动释放了对象的内存,那么同样的引用B再次释放同一块内存的时候就会报释放同一内存的错误.
ArrayList  a = oldArrayList.clone()浅 
ArrayList  a = new ArrayList(oldList)  浅
Collection.copy()  深

* 内存

  
  连接内存和寄存器的是地址总线，地址总线的宽度影响了物理地址的索引范围，因为总线宽度决定了处理器一次可以从寄存器或内存中获取多少个Bit，同时也决定了处理器最大可以寻址的地址空间。比如32位CPU的系统，可寻址范围为0x00000000~0xFFFFFFFF，即232=4294967296个内存位置，每个内存位置1个字节，即32位CPU系统可以有4GB的内存空间。不过应用程序是不可以完全使用这些地址空间的，因为这些地址空间被划分为了内核空间和用户空间，程序只能使用用户空间的内存。内核空间主要是指操作系统运行时所使用的用于程序调度、虚拟内存的使用或者链接硬件资源的程序逻辑。
  
  说到Java内存区域，可能很多人第一反应是“堆栈”。首先堆栈不是一个概念，而是两个概念，堆和栈是两块不同的内存区域，简单理解的话，堆是用来存放对象而栈是用来执行程序的。其次，堆内存和栈内存的这种划分方式比较粗糙，这种划分方式只能说明大多数程序员最关注的、与对象内存分配关系最密切的内存区域是这两块，Java内存区域的划分实际上远比这复杂。对于Java程序员来说，在虚拟机自动内存管理机制的帮助下，不再需要为每一个new操作去配对delete/free代码，不容易出现内存泄露和内存溢出问题。但是，也正是因为Java把内存控制权交给了虚拟机，一旦出现内存泄露和内存溢出的问题，就难以排查，因此一个好的Java程序员应该去了解虚拟机的内存区域以及会引起内存泄露和内存溢出的场景。
  
  .class文件的第5~第8个字节表示的是该.class文件的主次版本号，验证的时候会对这4个字节做一个验证，高版本的JDK能向下兼容以前版本的.class文件，但不能运行以后的class文件，即使文件格式未发生任何变化，虚拟机也必须拒绝执行超过其版本号的.class文件。举个具体的例子，如果一段.java代码是在JDK1.6下编译的，那么JDK1.6、JDK1.7的环境能运行这个.java代码生成的.class文件，但是JDK1.5、JDK1.4乃更低的JDK版本是无法运行这个.java代码生成的.class文件的。如果运行，会抛出java.lang.UnsupportedClassVersionError，这个小细节，务必注意。
  
***
## 类加载机制

对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。这句话表达地再简单一点就是：比较两个类是否"相等"，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则即使这两个类来源于同一个.class文件，被同一个虚拟机加载，只要加载它们的类加载器不同，这两个类必定不相等。
  
  
* java的三个类加载器:
  1 启动类加载器Bootstrap ClassLoader :一个嵌在JVM内核中的加载器。它负责加载的是JAVA_HOME/lib下的类库，属于系统级加载器,无法被Java程序直接应用
  2 扩展类加载器Extension ClassLoader:由 sun.misc.Launcher$ExtClassLoader 实现，它负责用于加载JAVA_HOME/lib/ext目录中的，或者被java.ext.dirs系统变量指定所指定的路径中所有类库，者可以直接使用扩展类加载器。
  3 应用程序类加载器Application ClassLoader :这个类加载器由 sun.misc.Launcher$AppClassLoader 实现。这个类也一般被称为 系统的 类加载器.      Application ClassLoader只能加载项目bin目录下的.class文件。
  
  
- System.out.println(System.getProperty("java.ext.dirs"));   sun.misc.Launcher$AppClassLoader@546b97fd
- System.out.printlngetSystemClassLoader().getParent());   sun.misc.Launcher$ExtClassLoader@535ff48b
- System.out.println(ClassLoader.getSystemClassLoader().getParent().getParent());  null    
```
Bootstrap ClassLoader以外的ClassLoader都是Java实现的，因此这些ClassLoader势必在Java堆中有一份实例在，所以Extension ClassLoader和Application 

ClassLoader都能打印出内容来。但是Bootstrap ClassLoader是JVM的一部分，是用C/C++写的，不属于Java，自然在Java堆中也没有自己的空间，所以就返回null

了。所以，如果ClassLoader得到的是null，那么表示的ClassLoader就是Bootstrap ClassLoader。
```
  
  - 双亲委派模型是在JDK1.2期间被引入的，其工作过程可以分为两步：  

  * 如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此。
  * 只有当父加载器反馈自己无法完成这这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载所以，其实所有的加载请求最终都应该传送到顶层的启动类加载器中。双亲委派模型对于Java程序的稳定运作很重要，因为Java类随着它的加载器一起具备了一种带有优先级的层次关系。例如java.lang.Object，存放于rt.jar中，无论哪一个类加载器要去加载这个类，最终都是由Bootstrap ClassLoader去加载,因此Object类在程序的各种类加载器环境中都是一个类。相反，如果没有双亲委派模型，由各个类自己去加载的话，如果用户自己编写了一个java.lang.Object，并放在CLASSPATH下，那系统中将会出现多个不同的Object类，Java体系中最基础的行为也将无法保证，应用程序也将会变得一片混乱。
---

## 多线程
* join()方法会使调用join()方法的线程（也就是mt线程）所在的线程（也就是main线程）无限阻塞，直到调用join()方法的线程销毁为止，此例中main线程就会无限期阻塞直到mt的run()方法执行完毕。join()方法的一个重点是要区分出和sleep()方法的区别。join(2000)也是可以的，表示调用join()方法所在的线程最多等待2000ms，两者的区别在于：sleep(2000)不释放锁，join(2000)释放锁，因为join()方法内部使用的是wait()，因此会释放锁。看一下join(2000)的源码就知道了，join()其实和join(2000)一样，无非是join(0)而已 .  假设在main线程中调用了另一个线程,另一个线程在执行了start之后又执行了join方法,那么main线程就会一直等待另一个线程执行完毕自己才会执行.可以这样来理解,线程都是cpu的儿子,他们都相互争抢cpu资源互不相让,当mt线程执行了start之后,mt开始执行,此时main千方百计想要让自己继续执行,但是mt线程执行了join方法,这就等同于告诉main线程,你想在我执行的时候进来插一脚那是不可能的,因为我用了join,join内部是wait,而wait是释放锁的,但是如果理解成mt释放锁,那不就很矛盾吗.所以,这儿的join虽然是mt调用的,但是实际上作用受体是main,也就是main被join了,也就是main被wait了.join相当于join(0),就是说main线程你一秒都别想插进来执行. 理解起来有点绕,可以直接记住结论,但是原理还是要想一想.
* 假如事先在一个线程的构造方法中用therd.getcurrentthread.getname打印,然后在main方法中去实例化这个线程对象,那么打印结果,线程的名字是main,如果在线程的run方法中去打印,然后再main方法中让线程对象.start,那么答应的结果就是当前那个线程名字.所以得出一个结论,在一个线程类中调用getcurrentthread.getname方法得到的不一定就是当前线程的名字.也就是 在main 在MyThread05里调用Thread.currentThread()返回回来的线程对象的引用未必就是MyThread05
* sleep(long millis)方法的作用是在指定的毫秒内让当前"正在执行的线程"休眠（暂停执行）。这个"正在执行的线程"是关键，指的是Thread.currentThread()返回的线程。根据JDK API的说法，"该线程不丢失任何监视器的所属权"，简单说就是sleep代码上下文如果被加锁了，锁依然在，但是CPU资源会让出给其他线程。 也就是说这个线程如果休眠了,它会保留自己的所有状态,让其他的线程先去执行,等自己睡醒了再接着执行.
* 这里有一个重要的概念。关键字synchronized取得的锁都是对象锁，而不是把一段代码或方法（函数）当作锁，哪个线程先执行带synchronized关键字的方法，哪个线程就持有该方法所属对象的锁，其他线程都只能呈等待状态。但是这有个前提：既然锁叫做对象锁，那么势必和对象相关，所以多个线程访问的必须是同一个对象。也就是说如果a线程先抢到了资源,那a就会一直执行完,就算是a在代码里休眠了,a也不会释方对象锁,b也只能一直干等着直到a睡醒了,执行完了b才会执行:  如果多个线程访问的是多个对象，那么Java虚拟机就会创建多个锁，就像上面的例子一样，创建了两个ThreadDomain13对象，就产生了2个锁。既然两个线程持有的是不同的锁，自然不会受到"等待释放锁"这一行为的制约，可以分别运行addNum(String userName)中的代码,所以这种情况就是谁抢到资源谁就执行.
 - 这里还有一个概念:静态同步方法和非静态同步方法持有的是不同的锁，前者是类锁，后者是对象锁。也就是说,虽然创建了多个对象,但是假如这个类中有个synchronized 的static方法,如果线程a调了这个方法,那就算线程b用的是这个类的一个新对象,那线程b也还是要等待线程a执行完才能执行这个静态的synchronized 方法.  这里再顺便提一下static这个关键字. 它代表静态,也就是说它修饰的属性是属于类的,只会在类初始化的时候初始化一次,内存也只有一份.你可以随时随地用这个类的类名来调用这些static的属性. 但如果不是属于静态的,那么就是对象级别的, 你每次创建一个对象,对象都会有各自的属性,新对象同样可以使用类属性,但是并不推荐这样做.
```
其实通过对synchronized 这个关键字的学习你会发现,在同一个编程体系中,很多特性都是共通的,内在都是有一套复杂但是条理清晰的逻辑.所以很多时候掌握特性的本

质是很有必要的,要会通过已掌握的东西去大概推测一些没有接触过个特性.特性可以千变万化,但是分析特性的思路,解决问题的方法都是共通的.
```
* 假如A类中有一个方法是synchronized,另一个方法是非synchronized,我现在写两个线程ab分别取调A中的synchronized,和非synchronized,方法,这时候ab两个线程是不会相互影响的,各调各的,各自抢占cpu资源,谁抢到谁执行. 假如我现在把A类中的非synchronized也改成synchronized,那就不一样了,虽然b线程调的方法和a线程调的方法不是同一个方法,但是b依然需要等到a执行完之后才能执行.  还有一点,一个线程如果获得了synchronized对象锁,那么它可以无限次的再次获取该对象的锁.也就是一个线程调了一个对象的synchronized方法,在这个synchronized方法中又调用了这个对象的另一个synchronized方法,在这个synchronized中又掉了另一个synchronized,可以这样一直调.  这就是 锁重入的机制，也支持在父子类继承的环境中。
* 当一个线程执行的代码出现异常时，其所持有的锁会自动释放。
* 一个线程如何出现了运行时异常且这个异常没有被捕获的话，这个线程就停止执行了。且如果这个线程持有某个对象的监视器，那么这个对象监视器会被立即释放.
* 无论synchronized关键字同步的是方法还是方法中的一部分方法块, 别的线程调用同一个对象的其他synchronized方法或者方法块的时候都是调不到的,都需要等待已经拿到锁的这个线程执行完成才能执行.  推而广之,如果用的不是synchronized(this)同步块,而是用的synchronized(另一个对象A当做监视器).假如线程a正在执行synchronized(另一个对象A当做监视器)这个块中的代码,有另一个线程b想执行A对象中的别的synchronized同步方法时也将阻塞先等待a执行完.  所以说只要一个对象与synchronized有关系的东西如果正在被一个线程执行,那么其他线程想执行和这个对象有关的其他synchronized同步方法或同步块或其他同步玩意之类的都是不行的.

* Volatile关键字
  - 修饰的成员变量在每次被线程访问时，都强迫从共享内存中重读该成员变量的值。而且，当成员变量发生变化时，强迫线程将变化值回写到共享内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。  
  - Java语言规范中指出：为了获得最佳速度，允许线程保存共享成员变量的私有拷贝，而且只当线程进入或者离开同步代码块时才与共享成员变量的原始值对比。这样当多个线程同时与某个对象交互时，就必须要注意到要让线程及时的得到共享成员变量的变化。而volatile关键字就是提示VM：对于这个成员变量不能保存它的私有拷贝，而应直接与共享成员变量交互。  
  - 建议在两个或者更多的线程访问的成员变量上使用volatile。当要访问的变量已在synchronized代码块中，或者为常量时，不必使用。由于使用volatile屏蔽掉了VM中必要的代码优化，所以在效率上比较低，因此一定在必要时才使用此关键字。
  - volatile的作用就是这样，被volatile修饰的变量，保证了每次读取到的都是最新的那个值。线程安全围绕的是可见性和原子性这两个特性展开的，volatile解决的是变量在多个线程之间的可见性，但是无法保证原子性。 
  - synchronized除了保障了原子性外，其实也保障了可见性。因为synchronized无论是同步的方法还是同步的代码块，都会先把主内存的数据拷贝到工作内存中，同步代码块结束，会把工作内存中的数据更新到主内存中，这样主内存中的数据一定是最新的。
  - volatile是线程同步的轻量级实现,性能肯定比synchronized要好,但是新版本的jdk中,synchronized关键字的效率已经得到很大程度的提升,所以在大多场景下,使用synchronized也是没有问题的.
  - 所谓的原子性就是同步性,也可以说成是互斥性.volatile虽然只能保证每次从主内存中取到最新的值,但是确不能保证每次写回主内存的值都是经过同步的,也就是说A在往主内存写的时候有可能B也在写,这样本来主内存的变量要改成A的那个,但是实际上最终被改成B的那个值了,这就不是互斥.所谓的线程安全实际上就是保证读和写都不能出错,读和写始终都只有一只手在操作,volatile只能保证读,不能保证写,就只写的时候可以有多只手,而synchronized无论是读还是写都只有一只手,只要这只手还没弄完,其他手就都得等待.

* 线程的sleep()方法

  看例子的时候经常看到自己写的mythread类中用了个Thread.sleep(100)或者this.sleep(100),又或者mythread.sleep(100),然后在测试的main方法中也有Thread.sleep(500),但是main方法中的基本都是Thread.sleep(500),没有类似于自己的线程类中那么多变体,原因如下:
  - sleep方法是Thread类的静态方法.
  - MyThread 中sleep前不用写Thread。是因为MyThread 继承了Thread类.
  - sleep(1000) 前面没有加类名或者对象名，表示默认当前对象的方法，mythread当前就是一个Thread所以可以不写，也可以写成this.sleep(1000)
  - 而TestInterrupt与Thread类无任何关系，所以必须使用Thread.sleep().如果在test类中直接用sleep(200),实际上指的是被调用的那个线程而不是主线程,所以必须明确的指明是主线程也就是main线程,所以是Thread.sleep().

* this.interrupted():测试当前线程是否已经是中断状态,执行后具有将中断状态标识清除的功能,也就是说假如这个你在这个线程中用if(interrupted)判断了当前线程的中断状态是true,那么当前线程的中断状态就被清除了,你再次用if(interrupted)判断时,就会是false.
* this.isinterrupted():判断当前线程是否是中断状态,但是并不清除中断标识.

* 用于强制停止线程的stop()方法已经被废弃,因为如果强制停止线程有可能使得一些清理性的工作得不到完成.另外就是stop()会强制解锁已经被锁定的对象,有可能导致对象的数据得不到同步出现数据不一致问题.

* 停止线程可以用如下方法: if(this.isiInterrupted) .....return; ,也可以用if(this.interrupted).....throw new interruptedException(); 推荐使用第二种,因为抛出异常之后异常能够被外层的代码捕获到,那么异常可以扩散,从而容易发现.
  
#### 锁重入机制
* 当一个线程得到一个对象的锁之后,可以再次得到这个对象的锁.就是说一个对象中有三个同步方法,在A中可以继续调用该对象的B,B中又可以继续调用C.如果没有锁重入机制,就会造成死锁.可重入锁机制支持在父子类继承的环境中.

#### 等待/通知机制
* 假设你的使用类test中有个变量list,类中有一个往list中set值和获取list大小的方法.现在建两个线程A和B,都有test类对象的参数,A用for循环不断往对象的list中set值,而B判断对象的list大小是不是等于一个值,如果等于就打印一行消息.然后创建测试类,在类中创建test类的对象,然后分别将这个对象传给新建的线程A和B,并分别启动线程,这时候两个线程就各自去干各自的事情.A一直往list中set值,而B一直去检查list的大小.实际上在这里就相当于线程A和线程B实现了通信,对象test中的list大小一直在增加,而对象增加的操作是在A中完成的,对象要如何将list大小告知B呢,那就是让B自己去检查,这就是一种通信.但是这种通信有弊端,就是当list的大小还没有到达B指定的临界点时,B一直都在空检查,就是说在浪费cpu资源.如果这个轮询的间隔很大,有可能A已经执行完了,list都被塞满了,大小早就超过B的临界点了,但B还没开始轮询呢,这就得不到想要的效果,而如果轮询时间间隔很小,虽然可以达到目的,但那就更浪费资源,所以就需要有一种机制能够减少cpu的资源浪费同时又能达到目的,实际上上面描述的那种通信是一种假通信,因为并不是双方预先的设定,而是各自去检查,在那种情况下,得到的值是不是想要的并不能完全确定.为了解决这个问题,wait/notify就出现了.
* wait的作用是让当前的线程进行等待,知道收到notify通知才开始执行,还是刚才那个例子,A一直在往list中放东西,现在加个判断,如果list的大小等于B的临界值了,A就调用notify发出一条消息,A执行了notify之后线程还是会继续执行.线程B中的代码除了加一行wait外其他不变,当线程B执行完第一次判断之后发现list大小不是自己想要的,他就wait了,就去等着了,直到它被通知唤醒,当被唤醒之后,list大小已经达到B想要的了,B就开始执行满足条件的代码.这样中间过程的很多次轮询就不需要了就可以省下很多cpu资源.  需要注意的是在调用wait或者notify之前,线程必须要获得一个对象级别的锁,也就是说只能在同步块中调用wait和notify,线程在执行了wait之后锁会被立即释放,而执行了notify不会立即释放而是继续执行同步块中的代码,直到同步块中的代码执行完了,锁被释放了,正在wait的线程才开始执行.  如果wait和notify在执行之前都没有获得相同对象的锁,则会抛出不合法通知异常,这个异常时运行时异常不需要用catch捕获.  还要注意的是,执行wait和notify的线程持有的锁必须是同一个对象的锁.也就是说有一个第三方的公证处来公正他们的行为,你可以用任何对象来当这个锁,而Java为每个对象都实现了wait和noti方法,你只需要在线程A和线程B中创建同样的对象比如说Object abc = new Object(),然后在代码里用abc.wait,和abc.notify就行了.之前很多例子创建这个对象的时候都是Object lock,我还一直以为是有个专门叫lock的对象呢,现在搞明白了,任何对象都是可以的,只不过他们把这个任意对象给叫了个lock.
* notifyAll可以给队列中的所有等待线程发出通知,等它的线程继续将同步代码执行完之后,其他wait线程就根据优先级竞争锁然后执行或者随机执行.
* 用wait和notify实现一个生产者消费者通知模型.假设有生产者类Product,里面有个锁对象Object lock;同时有个消费者类Consumer,里面也有同样的lock锁对象,这个和生产者中的lock是同一个.另外还有一个使用类,为了举例,在这个类中只定义一个空字符串str.在生产者类中取获取这个str,如果不为空就lock.wait,否则,执行赋值操作,然后lock.notify  在消费者类中也获取str,如果为空则lock.wait,否则打印str的值并把str置空,然后lock.notify  . 然后写两个线程类,一个是生产线程,里面用生产者对象set空串的值, 一个是消费线程,里面用消费对象get字符串的值.  最后写个测试类,新建一个lock,然后新建一个生产对象和一个消费对象,并把锁传给两个对象,然后新建生产和消费线程,并把两个对象分别传给对应的线程并启动,这便是一个简单的生产和消费模型.  每次生产者先去判断str是不是空,如果不是空,说明这个str还没被消费,那么生产者就wait了,放弃了lock锁去等待,这时候消费还在执行,消费者判断了这个字符不是空肯定进不了wait的分支,只能先打印然后把str置空,然后消费者notify了等待的生产者,这时候消费者继续执行自己的剩余代码,而生产者则从wait完的地方继续往后执行,就会去给str赋值并notify,而此时刚刚的消费者早就执行完毕,新的线程又启动了,消费者便又会去判断字符串的值,如此循环......
* 使用wait和notify构建的生产消费模型,如果用于很多个生产和消费线程,很有可能出现假死状态,就是说notify有可能通知了本类的线程,比如一个生产者执行完赋值notify之后,恰好唤醒的不是一个消费者而是另一个生产者,另一个生产者发现东西并没有被消费,就会等待,而本来要消费东西的消费者由于拿不到要消费的东西,也会逐渐全都进入到等待状态,最终所有线程都会进入等待状态导致全局假死.解决办法就是使用notifyall方法,每次都唤醒所有的线程而不是随机唤醒某一个. 这样可以确保全局不会假死,但是每次notifyall也是一个不小的内存消耗,这个后续再改进.
* Java提供了四个类可以使得线程间可已进行通信而不需要借助类似于临时文件之类的东西: 用于字节的 PipedInputStream 和 PipedOutputStream; 用于字符的PipedReader和PipedWriter.



