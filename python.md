### python中self的理解

java中如果建了一个布娃娃类,那你这个布娃娃类肯定会有颜色或大小或形状之类的属性,而且还有相应的构造方法.构造方法里会有一些简单的初始化,比如给新建的布娃娃
对象赋初始颜色为绿色.这个初始赋值是在对象被new的时候就完成的.你每次创建一个对象这个对象都会有默认的颜色绿色.  但是所有的布娃娃总不能一直都是绿色而且
不能所有的布娃娃都相同吧,所以会有那些大小或者形状属性,所以也就有了那些get和set方法.在出厂之前如果对哪个属性不满意还可以改.  

Python的逻辑也和Java是一样的,一个类就是一个工厂,我每次新建一个对象的时候也会有一些属性,当然你也会有对这些属性进行修改的方法.Python中的init方法就是对
每个新对象进行初始化的方法. 但是Python和Java有一个本质的不同, Java中一个类就是一个严格的对象工厂,每次new一个对象,那这个对象就会拥有这个类工厂中的所有
属性和方法. 而Python不是,Python中的对象属性是通过一个关键字来动态绑定的,这个关键字就是self. 当我每次新建一个Python对象的时候,只有类中用self绑定了的
方法和属性才能被赋给新对象. 而没有用self绑定的那些属性或方法,实际上它们是属于类的东西.也就相当于Java中的static属性.  Java中的static属性是可以直接用
类来调用的,新建的对象也可以调用但并不推荐这样用, 类比到Python也是一样, Python类中那些没有用self绑定的属性最合理的用法就是用类去调用他们,当然,你用新建
对象去调也没啥问题,但是你调的肯定是类的属性. Java有static来区分类属性和对象属性,但是Python没有,所有Python用了一个self来对属于实例化对象的属性进行了
一个关联.这才是self正确的理解.

其实,还有一个重要原因导致了Python会有self这个让人觉得多余又混乱的东西,那就是Python的这种设计方式其实还是受了**面向过程编程**的影响.来看一个例子:我现在
要对新建的一个布娃娃设置大小和形状,如果是面向过程编程,逻辑是这样的:
```
 先创建一个娃娃    baby = {};
 给布娃娃设置大小  set_size(baby,big);           // 如果是在面向对象中则是直接用对象 A.setSize()这样来调的
 给布娃娃设置形状  set_shape(baby,circle);
```
这就是面向过程的思路:执行完一步再执行下一步.在面向过程中,方法不和任何东西绑定,你只需要告方法要给谁干什么就行,其他你不管.方法知道了要给谁干什么之后就
屁颠屁颠去干了,干完了方法就去睡觉了,不管别的.  这里的要给谁干什么是关键点,理解了这一点就能理解Python中的self. Python的语法实际上是保留了面向过程的
一些东西,保留这个self,就相当于是告诉这个类,你要给一个名叫self的对象执行一个什么操作.这个self指代所有这个类的对象.Java中显示地用static区分了类中的类属性和对象属性,而Python中直接用一个self标示了对象属性,就跟在这个属性之前加了个关键字是一个意思. 而这个self是被用在类当中.当然你可以完全不用self,你可以用你想用的任何一个关键字来表示这种区分,只要能够区分这是对象属性就行了.这就是Python比Java高明的地方,在区分类属性和对象属性时,关键字可以自由定义.而使用self只是一种大家约定俗成的习惯.

反观那些真正的面向对象语言,比如Java,是完完全全的面向对象,你不需要告诉某个方法去给某个对象干个啥事,你只要新建个对象,然后你告诉你建的这个对象:睡觉,起床,跳两下,对象就自己去做了,你啥都不用操心.实际上当对象创建好之后,Python和Java的调用方式都是一样的,这个时候self已经不再需要了,只是在类中书写的时候Java和Python有区别.Python号称最简洁的语言,但是即便再简洁的代码也得能够明确表达语法的意思才行,Java用static关键字区分类和对象属性,而Python用了self, 这才是self的本质.

**Java中用static来区分类属性和实例属性,但是Python中没有相应的机制,而是用self来区分.本质和static是一样的.这是不同语法之间的差异.最终殊途同归**

**注意面向过程中的对象和面向对象变编程中的对象还是有很大差别的: 过程中的对象只是一光杆司令,啥都没有,但是面向对象里面的对象可是一个实打实的司令,手底下屯着千军万马.  所以在面向过程编程中,当你建了一对象的时候你只是完成了一个步骤,接下来你还需要一步一步给这个对象添加一些别的东西,而面向对象中只要对象被创建,那么这个对象就可以自己去完成自己能够完成的动作**

