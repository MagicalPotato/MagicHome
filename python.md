### python中self的理解

java中如果建了一个布娃娃类,那你这个布娃娃类肯定会有颜色或大小或形状之类的属性,而且还有相应的构造方法.构造方法里会有一些简单的初始化,比如给新建的布娃娃
对象赋初始颜色为绿色.这个初始赋值是在对象被new的时候就完成的.你每次创建一个对象这个对象都会有默认的颜色绿色.  但是所有的布娃娃总不能一直都是绿色而且
不能所有的布娃娃都相同吧,所以会有那些大小或者形状属性,所以也就有了那些get和set方法.在出厂之前如果对哪个属性不满意还可以改.  

Python的逻辑也和Java是一样的,一个类就是一个工厂,我每次新建一个对象的时候也会有一些属性,当然你也会有对这些属性进行修改的方法.Python中的init方法就是对
每个新对象进行初始化的方法. 但是Python和Java有一个本质的不同, Java中一个类就是一个严格的对象工厂,每次new一个对象,那这个对象就会拥有这个类工厂中的所有
属性和方法. 而Python不是,Python中的对象属性是通过一个关键字来动态绑定的,这个关键字就是self. 当我每次新建一个Python对象的时候,只有类中用self绑定了的
方法和属性才能被赋给新对象. 而没有用self绑定的那些属性或方法,实际上它们是属于类的东西.也就相当于Java中的static属性.  Java中的static属性是可以直接用
类来调用的,新建的对象也可以调用但并不推荐这样用, 类比到Python也是一样, Python类中那些没有用self绑定的属性最合理的用法就是用类去调用他们,当然,你用新建
对象去调也没啥问题,但是你调的肯定是类的属性. Java有static来区分类属性和对象属性,但是Python没有,所有Python用了一个self来对属于实例化对象的属性进行了
一个关联.这才是self正确的理解.

其实,还有一个重要原因导致了Python会有self这个让人觉得多余又混乱的东西,那就是Python的这种设计方式其实还是受了**面向过程编程**的影响.来看一个例子:我现在
要对新建的一个布娃娃设置大小和形状,如果是面向过程编程,逻辑是这样的:
 - 先创建一个娃娃    baby = {};
 - 给布娃娃设置大小  set_size(baby,big);
 - 给布娃娃设置形状  set_shape(baby,circle);

这就是面向过程的思路:执行完一步再执行下一步.意在面向过程中,方法不和任何东西绑定,你只需要告我我要给谁设置什么大小就行,其他你不管.我知道了要给谁设置啥
大小之后我就执行一步,执行完我就去睡觉了,再不管别的.  这里的要给谁设置是关键点,理解了这一点就能理解Python中的self.

