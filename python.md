### python中self的理解

java中如果建了一个布娃娃类,那你这个布娃娃类肯定会有颜色或大小或形状之类的属性,而且还有相应的构造方法.构造方法里会有一些简单的初始化,比如给新建的布娃娃
对象赋初始颜色为绿色.这个初始赋值是在对象被new的时候就完成的.你每次创建一个对象这个对象都会有默认的颜色绿色.  但是所有的布娃娃总不能一直都是绿色而且
不能所有的布娃娃都相同吧,所以会有那些大小或者形状属性,所以也就有了那些get和set方法.在出厂之前如果对哪个属性不满意还可以改.  

Python的逻辑也和Java是一样的,一个类就是一个工厂,我每次新建一个对象的时候也会有一些属性,当然你也会有对这些属性进行修改的方法.Python中的init方法就是对每个新对象进行初始化的方法. 但是Python和Java有一个本质的不同, Java中一个类就是一个严格的对象工厂,每次new一个对象,那这个对象就会拥有这个类工厂中的所有属性和方法. 而Python不是,Python中的对象属性是通过一个关键字来动态绑定的,这个关键字就是self. 当我每次新建一个Python对象的时候,只有类中用self绑定了的方法和属性才能被赋给新对象. 而没有用self绑定的那些属性或方法,实际上它们是属于类的东西.也就相当于Java中的static属性.  Java中的static属性是可以直接用类来调用的,新建的对象也可以调用但并不推荐这样用, 类比到Python也是一样, Python类中那些没有用self绑定的属性最合理的用法就是用类去调用他们,当然,你用新建对象去调也没啥问题,但是你调的肯定是类的属性. Java有static来区分类属性和对象属性,但是Python没有,所有Python用了一个self来对属于实例化对象的属性进行了一个关联.这才是self正确的理解.

其实,还有一个重要原因导致了Python会有self这个让人觉得多余又混乱的东西,那就是Python的这种设计方式其实还是受了**面向过程编程**的影响.来看一个例子:我现在要对新建的一个布娃娃设置大小和形状,如果是面向过程编程,逻辑是这样的:
```
 先创建一个娃娃    baby = {};
 给布娃娃设置大小  set_size(baby,big);           // 如果是在面向对象中则是直接用对象 A.setSize()这样来调的
 给布娃娃设置形状  set_shape(baby,circle);
```
这就是面向过程的思路:执行完一步再执行下一步.在面向过程中,方法不和任何东西绑定,你只需要告方法要给谁干什么就行,其他你不管.方法知道了要给谁干什么之后就
屁颠屁颠去干了,干完了方法就去睡觉了,不管别的.  这里的要给谁干什么是关键点,理解了这一点就能理解Python中的self. Python的语法实际上是保留了面向过程的
一些东西,保留这个self,就相当于是告诉这个类,你要给一个名叫self的对象执行一个什么操作.这个self指代所有这个类的对象.Java中显示地用static区分了类中的类属性和对象属性,而Python中直接用一个self标示了对象属性,就跟在这个属性之前加了个关键字是一个意思. 而这个self是被用在类当中.当然你可以完全不用self,你可以用你想用的任何一个关键字来表示这种区分,只要能够区分这是对象属性就行了.这就是Python比Java高明的地方,在区分类属性和对象属性时,关键字可以自由定义.而使用self只是一种大家约定俗成的习惯.

反观那些真正的面向对象语言,比如Java,是完完全全的面向对象,你不需要告诉某个方法去给某个对象干个啥事,你只要新建个对象,然后你告诉你建的这个对象:睡觉,起床,跳两下,对象就自己去做了,你啥都不用操心.实际上当对象创建好之后,Python和Java的调用方式都是一样的,这个时候self已经不再需要了,只是在类中书写的时候Java和Python有区别.Python号称最简洁的语言,但是即便再简洁的代码也得能够明确表达语法的意思才行,Java用static关键字区分类和对象属性,而Python用了self, 这才是self的本质.

**Java中用static来区分类属性和实例属性,但是Python中没有相应的机制,而是用self来区分.本质和static是一样的.这是不同语法之间的差异.最终殊途同归**

**注意面向过程中的对象和面向对象变编程中的对象还是有很大差别的: 过程中的对象只是一光杆司令,啥都没有,但是面向对象里面的对象可是一个实打实的司令,手底下屯着千军万马.  所以在面向过程编程中,当你建了一对象的时候你只是完成了一个步骤,接下来你还需要一步一步给这个对象添加一些别的东西,而面向对象中只要对象被创建,那么这个对象就可以自己去完成自己能够完成的动作**

### python工程目录的一些建议
* 假设你要新建一个项目名称是Foo的工程,那么如下这个目录是比较合理的:
```
Foo/                 # 名称后面带斜杠/的都表示文件夹 
|-- bin/             # bin/ 目录存放项目的一些可执行文件,当然也可以叫script/
|   |-- xxx.exe
|
|-- foo/             # foo/ 目录下存放项目的源代码 注意:不要只建foo一个包,里面放个__init__文件然后把所有源码都放这下面
|--                  # 源码要有合理的包结构和模块. 不要将源代码的目录命名为src或lib。有时候会导致安装困难.
|   |-- tests/       # test/ 目录下放工程的单元测试代码
|   |   |-- __init__.py
|   |   |-- test_main.py
|   |
|   |-- __init__.py  # python的每个包下都必须有一个__init__来标识这是一个包,否则这个包可能只被当成一个字符串来对待.
|   |-- main.py      # 启动整个工程的文件最好命名为main.py或者start.py.
|
|-- docs/            # 这个目录用来存放工程的文档. 工程的配置文件最好也放在这里.不要直接放在源码包中.很多人喜欢将配置文件
|   |-- conf.py      # 写成conf.py放在源码包中,使用的时候就直接import,这样做不太好. 首先如果单元测试用到了配置文件,那么
|   |-- abc.rst      # 跨包用这个配置文件很麻烦,二来用户大多会改动配置文件,硬编码在源码包中对用户不友好,代码复用性就差了.
|   |-- xxx.xxx      # 可以放在这里,然后在main.py启动时候通过参数指定配置路径的方式来让程序读取配置内容。
|
|-- setup.py         # 安装部署脚本,可以快速便捷的在一台新机器上将环境装好、代码部署好和将程序运行起来.
                     # 很多用户的问题并不在软件如何使用,而是如何把软件跑起来,所以能自动化的东西一定要自动化,要方便使用

|-- requirements.txt # 将开发过程中新增的包添加进这个列表中，避免在setup.py安装依赖时漏掉软件包。也方便读者了解项目用了哪些包
                     # 配置格式:xx包>=0.10,这种格式能被pip识别，可通过 pip install -r requirements.txt就能把所有包依赖都装好
|-- README           # 项目介绍文档.至少要讲清楚这个工程是干啥的,怎么用,详细点的可以把实现原理也说一说.
```

